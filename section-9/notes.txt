// Mutating variables
let a = 111;
let b = 999;
const obj = { a: 23, b: 7, c: 14 };
({ a, b } = obj);

// Nested objects
const {
  fri: { open: o, close: c },
} = openingHours;
console.log(o, c);

the spread operator works on all iterables (arrays, strings, maps, or sets but not objects)
we can only use the spread operator when building an array or when we pass values into a function

Rest Pattern (we compress)
const [a, b, ...others] = [1, 2, 3, 4, 5];
console.log(a, b, others); // others will be [3,4,5]

const {sat, ...weekdays} = restaurant.openingHours


// 2) Functions
const add = function (...numbers) {
  let sum = 0;
  for (let i = 0; i < numbers.length; i++) sum += numbers[i];
  console.log(sum);
};

add(2, 3);
add(5, 3, 7, 2);
add(8, 2, 5, 3, 2, 1, 4);

const x = [23, 5, 7];
add(...x);

// USE ANY data type, return ANY data type, short-circuiting
console.log(3 || 'Jonas');
ex: below 'Hello' will short circuit the entire operation
console.log(undefined || 0 || '' || 'Hello' || 23 || null);

ES2020 operator
The Nullish Coalescing Operator (??), nullish values are null and undefined
const guestsCorrect = restaurant.numGuests ?? 10;
here only nullish values will short-circuit the evaluation

ES2021 Logical OR Assignment Operators
rest1.numGuests = rest1.numGuests || 10;
rest1.numGuests ||= 10;
Logical Nullish Assignment Operator
rest1.numGuests ??= 10;

we also have Logical AND Assignment Operators
it assigns a value to a variable if it is truthy only
so if it would return undefined nothing will be returned

rest1.owner = rest1.owner && '<ANONYMOUS>';
rest1.owner &&= '<ANONYMOUS>';
so the first example above will return undefined to the object because rest1.owner is undefined whereas the second will return nothing